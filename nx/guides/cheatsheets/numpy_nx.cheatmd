# Numpy -> Nx

This cheatsheet is designed to assist Python developers in transitioning to Elixir, 
specifically by providing equivalent commands and code examples between NumPy and Nx.

## Tensor Creation
{: .col-2}

### Python

```python
>>> import numpy as np

# From list or nested list
>>> np.array([1, 2, 3])
array([1, 2, 3])
>>> np.array([[1, 2], [3, 4]])
array([[1, 2],
       [3, 4]])

# zeros and ones
>>> np.zeros((2, 3))
array([[0., 0., 0.],
       [0., 0., 0.]])
>>> np.ones((2, 3))
array([[1., 1., 1.],
       [1., 1., 1.]])

# Range of Numbers (like range())
>>> np.arange(0, 10, 2)
array([0, 2, 4, 6, 8])

# Linearly Spaced Values
>>> np.linspace(0, 1, 5)
array([0.  , 0.25, 0.5 , 0.75, 1.  ])

```

### Elixir

```elixir
iex> Mix.install([:nx, "~> 0.9"])
:ok

# From list or nested list
iex> Nx.tensor([1, 2, 3])
#Nx.Tensor<
  s32[3]
  [1, 2, 3]
>
iex> Nx.tensor([[1, 2], [3, 4]])
#Nx.Tensor<
  s32[2][2]
  [
    [1, 2],
    [3, 4]
  ]
>

# zeros and ones
iex> Nx.broadcast(0, {2, 3})
#Nx.Tensor<
  s32[2][3]
  [
    [0, 0, 0],
    [0, 0, 0]
  ]
>
iex> Nx.broadcast(1, {2, 3})
#Nx.Tensor<
  s32[2][3]
  [
    [1, 1, 1],
    [1, 1, 1]
  ]
>

# Range of Numbers (like range())
iex> Nx.iota({5}, axis: 0) |> Nx.multiply(2)
#Nx.Tensor<
  s32[5]
  [0, 2, 4, 6, 8]
>

# Linearly Spaced Values
iex> Nx.iota({5}) |> Nx.divide(4)
#Nx.Tensor<
  f32[5]
  [0.0, 0.25, 0.5, 0.75, 1.0]
>

```

## Tensor Inspection
{: .col-2}

### Python

```python
>>> import numpy as np

# Shape
>>> a = np.array([[1, 2, 3], [4, 5, 6]])
>>> a.shape
(2, 3)

# Number of dimensions
>>> a.ndim
2

# Data Type
>>> a.dtype
dtype('int64')

# Total Number of Elements
>>> a.size
6
```

### Elixir

```elixir
iex> Mix.install([:nx])
:ok

# Shape
iex> a = Nx.tensor([[1, 2, 3], [4, 5, 6]])
#Nx.Tensor<
  s32[2][3]
  [
    [1, 2, 3],
    [4, 5, 6]
  ]
>
iex> Nx.shape(a)
{2, 3}

# Number of dimensions
iex> Nx.rank(a) 
2

# Data Type
iex> Nx.type(a) 
{:s, 32}

# Total Number of Elements
iex> Nx.size(a)
6
```

## Indexing and Slicing
{: .col-2}

### Python
```python
>>> import numpy as np

# Indexing a Single Element
>>> a = np.array([[10, 20], [30, 40]])
>>> a[0, 1]  
np.int64(20)

# Slicing a Range
>>> a = np.array([10, 20, 30, 40, 50])
>>> a[1:4]  
array([20, 30, 40])

# Selecting Along a Specific Axis
>>> a = np.array([[1, 2], [3, 4], [5, 6]])
>>> a[:, 1]
array([2, 4, 6])

# Boolean Masking
>>> x = np.arange(10)
>>> x[x % 2 == 0] 
array([0, 2, 4, 6, 8])
```

### Elixir
```elixir
iex> Mix.install([:nx, "~> 0.9"])
:ok

# Indexing a Single Element
iex> tensor = Nx.tensor([[10, 20], [30, 40]])
#Nx.Tensor<
  s32[2][2]
  [
    [10, 20],
    [30, 40]
  ]
>
iex> tensor[[0, 1]]
#Nx.Tensor<
  s32
  20
>

# Slicing a Range
iex> a = Nx.tensor([10, 20, 30, 40, 50])
#Nx.Tensor<
  s32[5]
  [10, 20, 30, 40, 50]
>
iex> a[1..3]
#Nx.Tensor<
  s32[3]
  [20, 30, 40]
>

# Selecting Along a Specific Axis
iex> a = Nx.tensor([[1, 2], [3, 4], [5, 6]])
#Nx.Tensor<
  s32[3][2]
  [
    [1, 2],
    [3, 4],
    [5, 6]
  ]
>
iex> a[[.., 1]]
#Nx.Tensor<
  s32[3]
  [2, 4, 6]
>

# Boolean Masking
# requires dynamic shape behavior, which is not directly supported 
# in Nx because Nx compiles all operations ahead-of-time (like XLA or JAX), 
# and tensors must have static shapes.
```

## Linear Algebra Operations
{: .col-2}

### Python
```python
>>> import numpy as np

# Matrix Multiplication
>>> A = np.array([[1, 2], [3, 4]])
>>> B = np.array([[5, 6], [7, 8]])
>>> np.matmul(A, B)
array([[19, 22],
       [43, 50]])

# Transpose
>>> A.T
array([[1, 3],
       [2, 4]])

# Identity Matrix
>>> np.eye(3)
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])

# Determinant
>>> np.linalg.det(A)
np.float64(-2.0000000000000004)

# Inverse
>>> np.linalg.inv(A)
array([[-2. ,  1. ],
       [ 1.5, -0.5]])

# Solve a System of Linear Equations
>>> A = np.array([[3, 1], [1, 2]])
>>> b = np.array([9, 8])
>>> np.linalg.solve(A, b)
array([2., 3.])

# Eigenvalues and Eigenvectors
>>> np.linalg.eigh(A)
EighResult(eigenvalues=array([1.38196601, 3.61803399]), eigenvectors=array([[ 0.52573111, -0.85065081],
       [-0.85065081, -0.52573111]]))
```

### Elixir
```elixir
iex(108)> Mix.install([:nx])
:ok

# Matrix Multiplication
iex(111)> a = Nx.tensor([[1, 2], [3, 4]])
#Nx.Tensor<
  s32[2][2]
  [
    [1, 2],
    [3, 4]
  ]
>
iex(112)> b = Nx.tensor([[5, 6], [7, 8]])
#Nx.Tensor<
  s32[2][2]
  [
    [5, 6],
    [7, 8]
  ]
>
iex(114)> Nx.dot(a, b)
#Nx.Tensor<
  s32[2][2]
  [
    [19, 22],
    [43, 50]
  ]
>

# Transpose
iex(117)> Nx.transpose(a)
#Nx.Tensor<
  s32[2][2]
  [
    [1, 3],
    [2, 4]
  ]
>

# Identity Matrix
iex(120)> Nx.eye({3, 3})
#Nx.Tensor<
  s32[3][3]
  [
    [1, 0, 0],
    [0, 1, 0],
    [0, 0, 1]
  ]
>

# Determinant
iex(123)> Nx.LinAlg.determinant(a)
#Nx.Tensor<
  f32
  -2.0
>

# Inverse
iex(126)> Nx.LinAlg.invert(a)
#Nx.Tensor<
  f32[2][2]
  [
    [-2.000000476837158, 1.0000003576278687],
    [1.5000004768371582, -0.5000002384185791]
  ]
>

# Solve a System of Linear Equations
iex(129)> a = Nx.tensor([[3.0, 1.0], [1.0, 2.0]])
#Nx.Tensor<
  f32[2][2]
  [
    [3.0, 1.0],
    [1.0, 2.0]
  ]
>
iex(130)> b = Nx.tensor([9.0, 8.0])
#Nx.Tensor<
  f32[2]
  [9.0, 8.0]
>
iex(132)> Nx.LinAlg.solve(a, b)
#Nx.Tensor<
  f32[2]
  [2.0, 3.0]
>

# Eigenvalues and Eigenvectors
iex(135)> Nx.LinAlg.eigh(a)
{#Nx.Tensor<
   f32[2]
   [3.618025779724121, 1.381974220275879]
 >,
 #Nx.Tensor<
   f32[2][2]
   [
     [0.8516583442687988, -0.5240974426269531],
     [0.5240974426269531, 0.8516583442687988]
   ]
 >}
```